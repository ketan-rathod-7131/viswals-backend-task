package rabbitmq

import (
	"context"
	"errors"
	"fmt"
	"time"

	amqp "github.com/rabbitmq/amqp091-go"
	"go.uber.org/zap"
)

const (
	defaultDurable    = false
	defaultAutoDelete = false
	defaultExclusive  = false
	defaultNoWait     = false
	defaultQueueName  = "default-queue"
)

type ILogger interface {
	Debug(message string, args ...zap.Field)
}

// RabbitMQ struct contains the connection, channel.
type RabbitMQ struct {
	Connection *amqp.Connection
	Channel    *amqp.Channel
	logger     ILogger
}

type Option func(*RabbitMQ)

func WithLogger(logger ILogger) Option {
	return func(rm *RabbitMQ) {
		rm.logger = logger
	}
}

// New initializes a RabbitMQ connection with retry logic.
func New(amqpURL string, maxRetries int, retryInterval time.Duration, options ...Option) (*RabbitMQ, error) {
	var conn *amqp.Connection
	var err error

	rmq := &RabbitMQ{}

	for _, option := range options {
		option(rmq)
	}

	for attempt := 0; attempt < maxRetries; attempt++ {
		conn, err = amqp.Dial(amqpURL)
		if err == nil {
			break
		}

		if rmq.logger != nil {
			rmq.logger.Debug("failed to connect to RabbitMQ, retrying in %s", zap.Duration("retryInterval", retryInterval))
		}

		time.Sleep(retryInterval)
	}

	if err != nil {
		return nil, errors.New("failed to connect to RabbitMQ after max retries")
	}

	// open a channel
	ch, err := conn.Channel()
	if err != nil {
		conn.Close() // ensure we close the connection if channel creation fails
		return nil, err
	}

	rmq.Channel = ch
	rmq.Connection = conn

	return rmq, nil
}

// QueueDeclare provides a wrapper around rabbitmq's QueueDeclare method using optional parameters.
func (rmq *RabbitMQ) QueueDeclare(name string, options ...QueueOption) (amqp.Queue, error) {
	if name == "" {
		return amqp.Queue{}, fmt.Errorf("queue name cannot be empty")
	}

	// set default options
	var opts QueueOptions = QueueOptions{
		Durable:    defaultDurable,
		AutoDelete: defaultAutoDelete,
		Exclusive:  defaultExclusive,
		NoWait:     defaultNoWait,
		Arguments:  nil,
	}

	// override default options
	for _, option := range options {
		option(&opts)
	}

	// declare the queue with the given options and arguments
	q, err := rmq.Channel.QueueDeclare(
		name,
		opts.Durable,
		opts.AutoDelete,
		opts.Exclusive,
		opts.NoWait,
		opts.Arguments,
	)

	return q, err
}

// PublishWithContext provides a wrapper around rabbitmq's PublishWithContext method using optional parameters.
func (rmq *RabbitMQ) PublishWithContext(ctx context.Context, options ...PublishOption) error {

	// set default options
	var opts PublishOptions = PublishOptions{
		ContentType: "application/json",
		Body:        []byte{},
		Mandatory:   false,
		RoutingKey:  "",
	}

	// override default options
	for _, option := range options {
		option(&opts)
	}

	// publish the message to the queue with the given options and arguments
	err := rmq.Channel.PublishWithContext(
		ctx,
		"", // exchange
		opts.RoutingKey,
		opts.Mandatory,
		opts.Immediate,
		amqp.Publishing{
			ContentType: opts.ContentType,
			Body:        opts.Body,
		})

	return err
}

// ConsumeWithContext provides a wrapper around rabbitmq's ConsumeWithContext method using optional parameters.
func (rmq *RabbitMQ) ConsumeWithContext(ctx context.Context, queue string, options ...ConsumeOption) (<-chan amqp.Delivery, error) {
	if queue == "" {
		return nil, fmt.Errorf("queue name cannot be empty")
	}

	// set default options
	opts := ConsumeOptions{
		AutoAck:        true,
		Exclusive:      false,
		NoLocal:        false,
		NoWait:         false,
		QueueArguments: nil,
	}

	// override default options with provided ones
	for _, option := range options {
		option(&opts)
	}

	// consume messages from the queue with the given options
	deliveries, err := rmq.Channel.ConsumeWithContext(
		ctx,
		queue,
		"",                  // Consumer tag (empty means autogenerated)
		opts.AutoAck,        // AutoAck
		opts.Exclusive,      // Exclusive
		opts.NoLocal,        // NoLocal
		opts.NoWait,         // NoWait
		opts.QueueArguments, // QueueArguments
	)

	if err != nil {
		return nil, err
	}

	return deliveries, nil
}

func (rmq *RabbitMQ) Qos(prefetchCount, prefetchSize int, global bool) error {
	return rmq.Channel.Qos(prefetchCount, prefetchSize, global)
}

func (rmq *RabbitMQ) Close() error {
	return rmq.Connection.Close()
}
